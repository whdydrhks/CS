# DB   

<details>
<summary>❓ 데이터베이스의 특징에 대해 설명해주세요.</summary>
<div markdown="1">

1. **실시간 접근성(Real-Time Accessibility)**
비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 하며,
2. **지속적인 변화(Continuous Evolution)**
데이터베이스의 상태는 동적입니다. 즉, 새로운 데이터의 삽입(Insert), 삭제(Delete), 갱신(Update)으로 항상 최신의 데이터를 유지해야 합니다.
3. **동시 공용(Concurrent Sharing)**
데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 합니다.
4. **내용에 의한 참조(Content Reference)**
데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾습니다.

</div>
</details>

<details>
<summary>❓ 데이터베이스 언어(DDL, DML, DCL)에 대해 설명해주세요.</summary>
<div markdown="1">

**DDL (정의어: Data Definition Language)**<br>
테이블
데이터베이스 구조를 정의, 수정, 삭제하는 언어<br>- create, alter, drop

**DML (조작어: Data Manipulation Language)**<br>
테이블 내 컬럼
데이터베이스내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어<br> - insert, select, update, delete

**DCL (제어어: Data Control Language)**<br>
권한
데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어<br>- commit, rollback, grant, revoke


</div>
</details>

<details>
<summary>❓ SELECT 쿼리의 수행 순서를 알려주세요.</summary>
<div markdown="1">

> FROM, ON, JOIN ➡️ WHERE ➡️ GROUP BY ➡️ HAVING ➡️ SELECT ➡️ DISTINCT ➡️ ORDER BY ➡️ LIMIT
> 
1. FROM: 각테이블을 확인한다.
ON: JOIN 조건을 확인한다.
JOIN: JOIN이 실행되어 데이터가 SET으로 모아지게 된다. 서브쿼리도 함께 포함되어 임시 테이블을 만들 수 있게 도와준다.
2. WHERE: 데이터셋을 형성하게 되면 WHERE 조건이 개별 행에 적용된다. WHERE 절의 제약 조건은 FROM 절로 가져온 테이블에 적용될 수 있다.
3. GROUP BY: WHERE 조건 적용 후 나머지 행은 GROUP BY 절에 지정된 열의 공통 값을 기준으로 그룹화된다. 쿼리에 집계  기능이 있는 경우에만 이 기능을 사용해야 한다.
4. HAVING: GROUP BY 절이 쿼리에 있을 경우, HAVING 절의 제약조건이 그룹화된 행에 적용된다.
5. SELECT: SELECT에 표현된 식이 마지막으로 적용된다.
6. DISTINCT: 표현된 행에서 중복된 행은 삭제
7. ORDER BY: 지정된 데이터를 기준으로 오름차순, 내림차순 지정
8. LIMIT: LIMIT에서 벗어나는 행들은 제외되어 출력된다.


</div>
</details>

<details>
<summary>❓ 트리거(Trigger)에 대해 설명해주세요.</summary>
<div markdown="1">

- 트리거는 특정 테이블에 대한 이벤트에 반응해 INSERT, DELETE, UPDATE 같은 DML 문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램입니다.
- 사용자가 직접 호출하는 것이 아닌, 데이터베이스에서 자동적으로 호출한다는 것이 가장 큰 특징입니다.

</div>
</details>

<details>
<summary>❓ Index에 대해 설명해주시고, 장/단점에 대해 아는대로 말해주세요.</summary>
<div markdown="1">

- Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법입니다.
    - 예를 들어, DB를 책으로 비유하면 데이터는 책의 내용일 것이고, 데이터가 저장된 레코드의 주소는 index 목록에 있는 페이지 번호일 것이다.
- 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠르지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.
- 즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 속도를 높이는 기능이라 할 수 있습니다.

</div>
</details>

<details>
<summary>❓ 그렇다면 DBMS는 Index를 어떻게 관리하고 있나요? (Index 자료구조)</summary>
<div markdown="1">

- B+ Tree 인덱스 자료구조
    - 자식 노드가 2개 이상인 B- Tree를 개선시킨 자료구조이며,
    - B Tree 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 합니다. 해시 테이블보다 나쁜 O(log2N)의 시간복잡도를 갖지만 일반적으로 사용되는 자료구조입니다.
- 해시 테이블
    - 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현합니다.
    - 시간복잡도가 O(1)이라 검색이 매우 빠릅니다.
    - 부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하기 때문에 사용에 적합하지 않습니다.

</div>
</details>

<details>
<summary>❓ 정규화에 대해 설명해주세요.</summary>
<div markdown="1">

하나의 릴레이션(relation-테이블)에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며, 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.

- 제 1 정규형: 테이블의 컬럼이 원자 값(Atomic Value: 하나의 값)을 갖도록 분해합니다.

- **제 2 정규형**: 제 1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 ***완전 함수 종속***이도록 분해합니다.
    
    ****완전함수종속***: 기본키로 묶인 복합키가 존재할 때 복합키(A,B,C)가 모여서 하나의 다른 값(X)를 결정하고 복합키의 부분집합이 결정자가 되면 안된다는 뜻입니다.

- **제 3 정규형**: 제 2정규형을 만족하고, ***이행적 함수 종속***을 없애도록 분해합니다.
    
    ****이행적 함수 종속***: A→B, B→C가 성립할 때 A→C가 성립되는 것을 의미

- BCNF 정규형: 제3 정규화를 만족하고, 모든 결정자가 후보키가 되도록 테이블을 분해하는 것입니다.

</div>
</details>

<details>
<summary>❓ 정규화에는 어떤 장점이 있고 어떤 단점이 있는지 아는대로 설명해주세요.</summary>
<div markdown="1">

**장점**

1. 데이터베이스 변경 시 이상현상이 발생하는 문제점을 해결할 수 있다.
2. 데이터베이스 구조 확장 시 정규화된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.

**단점**

릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아진다. 이로인해 질의에 대한 응답 시간이 느려질 수 있다.

+ 정규화를 수행한다는 것은 이상현상을 제거하는 것이다. 
데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다.

따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있는 특성이 있다.

</div>
</details>

<details>
<summary>❓ 역정규화를 하는 이유에 대해 아는대로 설명해주세요.</summary>
<div markdown="1">

정규화를 거치면 릴레이션 간의 연산(JOIN 연산)이 많아지는데, 이로 인해 성능이 저하될 우려가 있다.

역정규화를 하는 가장 큰 이유는 성능 문제가 있는(읽기 작업이 많이 필요한) DB의 전반적인 성능을 향상 시키기 위함이다.

</div>
</details>

<details>
<summary>❓ 이상 현상의 종류에 대해 설명해주세요.</summary>
<div markdown="1">

  이상 현상은 테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류를 말한다.
1. **삽입 이상**: 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상 (자료를 삽입할 때 의도하지 않은 자료까지 삽입해야만 자료를 테이블에 추가가 가능한 현상)
    
    - Ex) 수강테이블(학번, 이름, 나이, 성별, 강의코드, 강의명, 강의실, 전화번호) 이 있는데,
    
    - 강의를 아직 수강하지 않은 새로운 학생을 삽입할 시 강의코드, 강의명, 강의실이 null 값이 들어가야 된다.
    
2. **갱신 이상**: 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
    
    - Ex) 수강테이블(학번, 이름, 나이, 성별, 강의코드, 강의명, 강의실, 전화번호) 이 있는데,
    
    - [101, 김철수, 23, 남, DB, 데이터베이스, 공학관, 111-111]
    
    - [101, 김철수, 23, 남, NW, 네트워크, 전산실, 111-111] 
    
    - 이렇게 있을때, DB 수업을 듣는 김철수의 전화번호를 222-222로 수정하게 되면,
    
    - NW 수업을 듣는 같은 사용자 김철수의 번호가 다르게 된다.
    
3. **삭제 이상**: 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상
    
    - 위의 예시에서, DB를 삭제하게 되면, 김철수 학생의 데이터까지 삭제가 된다.
    

이러한 이상 현상을 예방하고 효과적인 연산을 하기 위해 데이터 정규화를 한다.

</div>
</details>

<details>
<summary>❓ SQL Injection이 무엇인지 설명해주세요.</summary>
<div markdown="1">

SQL Injection이란 공격자가 악의적인 의도로 갖는 SQL 구문을 삽입하여 

데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법입니다.

</div>
</details>

<details>
<summary>❓ SQL Injection을 방어 및 방지하기 위한 방법에 대해 알고 있다면 설명해주세요.</summary>
<div markdown="1">

1. 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우 입력된 값이 개발자가 의도한 값(유효값)인지 검증합니다.
2. 저장 프로시저를 사용합니다.
    
    * 저장 프로시저란 사용하고자 하는 Query에 미리 형식을 지정하는 것.
    * 지정한 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상 된다.

</div>
</details>

<details>
<summary>❓ RDBMS와 NoSQL의 차이에 대해 설명해주세요.</summary>
<div markdown="1">

**RDBMS**는 모든 데이터를 *2차원 테이블 형태*로 표현합니다.

- 장점: 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.
- 단점: 시스템이 커질수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)

**NoSQL-Not Only SQL**은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, *컬렉션*이라는 형태로 데이터를 관리합니다.

**[ 장점 ]**

- 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.
- 데이터 분산이 용이하여 성능 향상을 위한 scale-up뿐만 아니라 scale-out 또한 가능하다.

**[ 단점 ]**

- 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.
- 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.

</div>
</details>

<details>
<summary>❓ 그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?</summary>
<div markdown="1">

**[ RDBMS ]**

데이터 구조가 명확하고, 변경 될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋다. 또한 중복된 데이터가 없어(데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합하다.

**[ NoSQL ]**

정확한 데이터 구조를 알 수 없고, 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋다.

또한 단점에서도 명확하듯 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update가 많이 이루어지지 않는 시스템에 좋으며, Scale-out이 가능하다는 장점을 활용해 막대한 데이터를 저장해야 해서 DB를 Scale-out 해야 되는 시스템에 적합하다.

</div>
</details>

<details>
<summary>❓ 트랜잭션이란 무엇인지 설명해주세요.</summary>
<div markdown="1">

- 트랜잭션은 작업의 완전성을 보장해줍니다.
- 즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.
- 하나의 트랜잭션은 Commit(작업완료) 되거나 Rollback(취소) 됩니다.

</div>
</details>

<details>
<summary>❓ 트랜잭션의 특성(ACID)에 대해 설명해주세요.</summary>
<div markdown="1">

1. 원자성(Atomicity): 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
2. 일관성(Consistency): 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
3. 독립성(Isolation): 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
4. 영속성(Durability): 완료된 결과는 영구적으로 반영되어야 한다.

</div>
</details>

<details>
<summary>❓ DB 락에 대해 설명해주세요.</summary>
<div markdown="1">

- DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법입니다.
- **공유락(Shared Lock)**: **Read Lock**라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만 하기 때문에 같은 공유락끼리는 동시에 접근이 가능합니다.
- **배타락(Exclusive Lock)**: **Write Lock**라고도 하는 배타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 배타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다.

</div>
</details>

<details>
<summary>❓ Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.</summary>
<div markdown="1">

- RDBMS는 단순 텍스트 매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다.
- (MySQL 최신 버전에서 n-gram 기반의 Full-Text 검색을 지원하긴 하지만, 한글 검색의 경우 아직 많이 빈약한 감이 있습니다.)
- 하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능합니다.

Full-Text: 이미지, CSS, 글 등의 복합적으로 이뤄진 컨텐츠에서 순수하게 텍스트만 추출한 데이터를 의미, 이 과정을 보통 크롤링으로 구현함(엘라스틱 서치의 검색엔진엔 크롤러가 빠져있어 별도로 구축해야함)

</div>
</details>

<details>
<summary>❓ 옵티마이저(Optimizer)에 대해 아는대로 말해주세요.</summary>
<div markdown="1">

- 옵티마이저는 SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진입니다.
- 컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있습니다. 개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 “이 쿼리문을 어떻게 실행시키겠다!” 라는 여러가지 실행 계획을 세우고, 최고의 효율을 갖는 실행 계획을 판별한 후, 그 실행 계획에 따라 쿼리를 수행하게 되는 것입니다.

</div>
</details>

<details>
<summary>❓ DB 튜닝(Tuning)이 무엇인지 그리고 튜닝의 3단계에 대해 설명해주세요.</summary>
<div markdown="1">

- DB 튜닝이란 DB의 구조나, DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업을 말합니다.
- 튜닝은 DB 설계 튜닝 → DBMS 튜닝 → SQL 튜닝 단계로 진행할 수 있습니다.
- 1단계 - DB 설계 튜닝(모델링 관점)
    - DB 설계 단계에서 성능을 고려하여 설계
    - 데이터 모델링, 인덱스 설계
    - 데이터 파일, 테이블 스페이스 설계
    - 데이터베이스 용량 산정
    - 튜닝 사례 - 반정규화, 분산파일배치
- 2단계 - DBMS 튜닝(환경 관점)
    - 성능을 고려하여 메모리나 블록 크기 지정
    - CPU, 메모리 I/O에 관한 관점
    - 튜닝 사례 - Buffer 크기, Cache 크기
- 3단계 - SQL 튜닝(App 관점)
    - SQL 작성 시 성능 고려
    - Join, Indexing, SQL Execution Plan
    - 튜닝 사례 - Hash/Join

</div>
</details>